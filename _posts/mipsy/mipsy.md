# MIPSY

# ![mipsy](/assets/img/mipsy/mipsy.jpg)

## Introduction

MIPSY is a Medium difficulty Linux machine that simulates a firmware developer's workstation used for building and testing binaries for a SquashFS-based ONT (Optical Network Terminal) firmware. The machine features a custom telnet-like firmware console service on port 23 that exposes internal firmware files. Players must discover hardcoded credentials inside a firmware configuration XML, use those credentials to gain SSH access, then identify and execute a cross-architecture MIPS binary to extract the root password.

The box highlights realistic vulnerabilities found in embedded/IoT development environments: hardcoded credentials in firmware configuration files, password reuse across services, and legacy authentication schemes in developer tooling.

## Info for HTB

### Access

Passwords:

| User       | Password                                   |
| ---------- | ------------------------------------------ |
| arthur.dev | `qeqemutz`                                  |
| root       | `72c0a34491ac419`                           |
| fake-telnet     | guest (empty password) / anonymous:anonymous |

> **Note**: The root password is the first 15 characters of a SHA-256 hash generated by the `photonctl` MIPS binary. It is deterministic based on the firmware version files and arthur.dev's password as token. Although running on port 23, the service is a custom console and not a real Telnet implementation. The configuration file resides inside the firmware image exposed by the developer console. The idea of ​​forcing the player to use qemu-mipsel is to make them learn how to run a mips binary in a Linux environment. The squashfs-root in dev's home is in development, and the one in /opt is in production.
> **All commands to root**: nmap -F mipsy.htb; telnet mipsy.htb 23; cat ../etc/config_default.xml (fake-telnet);ssh arthur.dev@mipsy.htb; qemu-mipsel /home/arthur.dev/firmware-dev/squashfs-root/bin/photonctl qeqemutz;

### Key Processes

| Service              | Description                                                    | Port | Unit File              |
| -------------------- | -------------------------------------------------------------- | ---- | ---------------------- |
| fake-telnet.service  | Custom Python service simulating a firmware management console | 23   | fake-telnet.service    |
| ssh                  | OpenSSH server (password auth only, root login disabled)       | 22   | ssh.service            |

**fake-telnet.service**: A custom Python 3 application (`/usr/local/lib/photon/fake_telnet.py`) that implements a telnet-like firmware console. It supports IAC negotiation, a file browser restricted to `/opt`, and basic authentication with guest/anonymous credentials. The service runs as the `telnet` system user with strict systemd sandboxing (ProtectSystem=strict, ReadOnlyPaths=/opt, CapabilityBoundingSet=CAP_NET_BIND_SERVICE). Source code: `fake_telnet.py` (attached).

**photonctl**: A custom C binary compiled for MIPS (little-endian) architecture. It reads `/etc/photon/fwu_ver` and `/etc/photon/hw_ver`, takes a token argument, computes `SHA-256(fwu_ver | "|" | hw_ver | "|" | token)`, and outputs the first 15 hex characters as the "Root credential". The binary is placed inside a SquashFS root filesystem in the user's home directory. Source code: `generate_hash.c` (attached).

### Automation / Crons

No cron jobs or scheduled tasks are configured on this machine. The fake-telnet service is started at boot via systemd.

### Firewall Rules

No firewall rules are configured. UFW is disabled. iptables policies are set to ACCEPT on all chains.

### Docker

Docker is not used on this machine.

### Other

- `qemu-user` (specifically `qemu-mipsel`) is installed to allow execution of the MIPS binary on the x86 host. This is intentional and part of the exploitation path.
- The firmware version files (`fwu_ver`, `hw_ver`) are owned by root and read-only to prevent players from manipulating the hash output.
- A partial C source file (`photonctl.c`) is placed in arthur.dev's home directory as a hint. It contains the header comments indicating that the tool uses the developer's system password as token and returns a root credential, plus the SHA-256 implementation, but the `main()` function is incomplete — the player must execute the compiled MIPS binary to get the actual output.
- PermitRootLogin is set to `no` in sshd_config. The player must use `su root` after obtaining the root credential from photonctl.
- All history files are symlinked to `/dev/null`.

---

## Writeup

### Enumeration

## Nmap Scan

We start with a full port scan to identify running services.

```bash
nmap -sC -sV -p- mipsy.htb
```


# ![nmap](/assets/img/mipsy/nmap.jpg) 

Two ports are open: SSH on port 22 and a custom service on port 23 that identifies itself as "PHOTON GATEWAY — FIRMWARE CONSOLE". The banner explicitly mentions that guest or anonymous access is enabled for diagnostics.

## Telnet Service Exploration

We connect to port 23 using a telnet client.

```bash
telnet mipsy.htb 23
```

The service displays a banner with firmware information and prompts for credentials. Based on the banner hint, we log in with `guest` and an empty password.

```
╔══════════════════════════════════════════════════════════╗
║          PHOTON GATEWAY — FIRMWARE CONSOLE               ║
║         Access only for Firmware Developers              ║
║    guest or anonymous access enabled for diagnostics     ║
║                       BETA VERSION                       ║
║──────────────────────────────────────────────────────────║
║  Model   : Photon-LDv1        HW Rev : HW-REV-B          ║
║  Firmware : FWU-2.1.7          Uptime : 0d 2h 15m        ║
╚══════════════════════════════════════════════════════════╝

Username: guest
Password:
Login OK.
```

After logging in, we see a menu. We select option `[2] Files` to enter the file browser.

```
  [1] System Info
  [2] Files
  [3] Firmware version
  [0] Disconnect

photon> 2
```
# ![ftelnet](/assets/img/mipsy/fake_telnet.jpg)

## Firmware File Browser

The file browser starts inside the SquashFS firmware directory. We navigate to the root to get an overview.

```
files:/firmware/squashfs-root/bin$ cd /
files:/$ ls
  [DIR ] firmware                            0 bytes
```

We explore the firmware directory structure, looking for configuration files.

```
files:/$ cd /firmware/squashfs-root/etc
files:/firmware/squashfs-root/etc$ ls
```

We find a configuration XML file and read it with `cat`.

```
files:/firmware/squashfs-root/etc$ cat config_default.xml
```

```xml
<Value Name="DMZ_ENABLE" Value="0"/>
<Value Name="DMZ_IP" Value="0.0.0.0"/>
<Value Name="USER_NAME" Value="arthur.dev"/>
<Value Name="USER_PASSWORD" Value="qeqemutz"/>
<Value Name="PROTOCOL_TYPE" Value="ssh"/>
<Value Name="DEVICE_TYPE" Value="1"/>
<Value Name="INIT_LINE" Value="1"/>
<Value Name="INIT_SCRIPT" Value="1"/>
```
# ![userpass](/assets/img/mipsy/userpass.jpg)

The XML configuration file contains multiple user credentials in cleartext. We note the `arthur.dev` developer account with its password. There is also a `superuser` account with a different password that serves as a red herring.

### Foothold

## SSH Access as arthur.dev

We try the credentials from the firmware XML to access the machine via SSH, testing password reuse.

```bash
ssh arthur.dev@mipsy.htb
```

Using the password found in the XML for `arthur.dev`, we successfully authenticate.

```
arthur.dev@mipsy:~$ whoami
arthur.dev
arthur.dev@mipsy:~$ cat user.txt
<USER_FLAG>
```
# ![userflag](/assets/img/mipsy/userflag.jpg)

We obtain the **user flag**.

### Privilege Escalation

## Discovery — photonctl.c

We begin by exploring the user's home directory.

```bash
arthur.dev@mipsy:~$ ls -la
```

We find a C source file called `photonctl.c` — partial source code left behind by the developer.

```bash
arthur.dev@mipsy:~$ cat photonctl.c
```

The file header contains critical information:

```c
/*
 * photonctl.c - photonctl authentication module
 * 
 * NOTE: photonctl binary is deployed to the firmware squashfs 
 *       the validator still uses the developer's system password as the
 *       authentication token. This needs to be migrated to certificate-based
 *       auth before production release. -- Arthur M.
 */
```

And further down:

```c
 /* validate_token: authenticate developer access using system credentials
  * Returns the firmware root credential on success ONLY for testing purposes.
  * See photonctl for the full implementation. 
  */
```

# ![photonctlc](/assets/img/mipsy/photonctlc.jpg)

The source code reveals that:
1. There is a binary called `photonctl` deployed to the firmware SquashFS
2. It uses the developer's **system password** as the authentication token
3. It returns a **firmware root credential** on success
4. The code includes a SHA-256 implementation, but the `main()` function is incomplete — the full implementation is only in the compiled binary

## Locating and Identifying photonctl

Based on the source code hint ("deployed to the firmware squashfs"), we look for a SquashFS filesystem in the user's home directory.

```bash
arthur.dev@mipsy:~$ find ~ -name photonctl 2>/dev/null
```

We locate the binary and identify its architecture:

```bash
arthur.dev@mipsy:~$ file ~/firmware-dev/squashfs-root/usr/bin/photonctl
```

```
photonctl: ELF 32-bit LSB executable, MIPS, MIPS32 rel2 version 1 (SYSV), statically linked, ...
```

The binary is a **MIPS 32-bit little-endian ELF**. Since the machine is x86-based, we cannot execute it directly. We check if there is a MIPS emulator available on this firmware development machine:

```bash
arthur.dev@mipsy:~$ which qemu-mipsel
/usr/bin/qemu-mipsel
```

The presence of `qemu-mipsel` is consistent with a firmware development environment that builds and tests MIPS binaries.

## Executing photonctl

We navigate to the binary's directory and run it with `qemu-mipsel`. From the source code we know the token is the developer's "system password" — the same password we used to SSH in.

```bash
arthur.dev@mipsy:~$ cd firmware-test/squashfs-root/usr/bin/
arthur.dev@mipsy:~/firmware-test/squashfs-root/usr/bin$ qemu-mipsel ./photonctl
```

```
Use: ./photonctl <token>
```

```bash
arthur.dev@mipsy:~/firmware-test/squashfs-root/usr/bin$ qemu-mipsel ./photonctl '<ARTHUR_PASSWORD>'
```

```
[+] Token validated.
[+] Root credential: <15_HASH_CHARS>
```

# ![qemumipsel](/assets/img/mipsy/qemumipsel.jpg)

The tool validates our token and outputs a "Root credential" — a 15-character hash string derived from firmware metadata and the developer token.

## Root Access

We use the credential output by photonctl to switch to the root user.

```bash
arthur.dev@mipsy:~$ su root
Password: <15_HASH_CHARS>
root@mipsy:~# whoami
root
root@mipsy:~# cat /root/root.txt
<ROOT_FLAG>
```

We obtain the **root flag**. The machine is fully compromised.


# ![root](assets/img/mipsy/root.jpg)

---

## Attack Path Summary

```
nmap scan
  └── Port 23: Photon Firmware Console (fake telnet)
        └── Login as guest (empty password)
              └── File browser → squashfs → XML config
                    └── arthur.dev password in cleartext (password reuse)
                          └── SSH as arthur.dev → user.txt
                                └── photonctl.c source stub (hint: system password = token)
                                      └── find photonctl binary (MIPS ELF) in squashfs
                                            └── file photonctl → MIPS → qemu-mipsel
                                                  └── qemu-mipsel photonctl <password>
                                                        └── Root credential → su root → root.txt
```
